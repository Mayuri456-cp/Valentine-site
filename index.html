<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Will you be my Valentine?</title>

  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1: #ffd6e8;
      --bg2: #ffb3d1;
      --accent: #e91e63;
      --accent-dark: #c2185b;
      --white: #fff;
      --glass: rgba(255,255,255,0.65);
      --shadow: 0 8px 24px rgba(193, 39, 88, 0.16);
      --maxWidth: 920px;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      color: #3b1b2b;
    }

    /* Subtle animated floating hearts background */
    .bg-hearts{
      position: fixed;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
      z-index: 0;
    }
    .heart{
      position: absolute;
      width: 28px;
      height: 28px;
      transform: scale(.8);
      opacity: 0.18;
      animation: floatUp linear infinite;
      filter: drop-shadow(0 6px 10px rgba(200,20,80,0.12));
    }
    .heart::before,
    .heart::after{
      content: "";
      position: absolute;
      width: 14px;
      height: 22px;
      background: radial-gradient(circle at 30% 30%, #fff5f7, transparent 60%), linear-gradient(#ff9ec8, #ff6fa8);
      border-radius: 14px 14px 0 0;
      transform-origin: bottom;
    }
    .heart::before{ left: 0; transform: rotate(-45deg); border-top-left-radius: 14px; }
    .heart::after{ right: 0; transform: rotate(45deg); border-top-right-radius: 14px; }
    @keyframes floatUp{
      from { transform: translateY(0) scale(.8); opacity: .18; }
      to   { transform: translateY(-120vh) scale(1.05); opacity: 0; }
    }

    /* Main container */
    .wrap{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      position:relative;
      z-index: 2;
    }

    .card{
      width: min(94%, var(--maxWidth));
      background: linear-gradient(180deg, rgba(255,255,255,0.7), rgba(255,255,255,0.55));
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: clamp(28px, 4vw, 56px);
      text-align:center;
      position:relative;
      overflow:visible;
      backdrop-filter: blur(6px) saturate(120%);
      border: 1px solid rgba(255,255,255,0.6);
    }

    h1{
      margin: 0 0 10px 0;
      font-family: 'Pacifico', cursive;
      font-size: clamp(30px, 5vw, 48px);
      color: var(--accent-dark);
      letter-spacing: 0.6px;
    }
    p.lead{
      margin: 0 0 26px 0;
      font-size: clamp(14px, 2.2vw, 18px);
      color: #5c2237;
      max-width: 760px;
      margin-left:auto;
      margin-right:auto;
    }

    /* Buttons area */
    .actions{
      display:flex;
      gap:18px;
      justify-content:center;
      margin-top: 10px;
      flex-wrap:wrap;
    }

    .btn{
      appearance:none;
      border: none;
      cursor:pointer;
      padding: clamp(10px, 1.6vw, 14px) clamp(18px, 3.2vw, 22px);
      font-size: clamp(14px, 1.9vw, 18px);
      border-radius: 999px;
      font-weight:600;
      background: var(--white);
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
      transition: transform .12s ease, box-shadow .12s ease;
      position:relative;
    }
    .btn:active{ transform: translateY(1px) scale(.995); }
    .btn--yes{
      color: var(--white);
      background: linear-gradient(180deg, var(--accent), var(--accent-dark));
      box-shadow: 0 12px 30px rgba(225, 30, 99, 0.22);
    }
    .btn--yes:focus{
      outline: 3px solid rgba(233,30,99,0.15);
      outline-offset: 4px;
    }

    /* No button starts normal */
    .btn--no{
      background: #fff8fb;
      color: var(--accent-dark);
      border: 1px solid rgba(225,30,99,0.06);
    }
    .btn--no[aria-hidden="true"]{ pointer-events:none; }

    /* small caption */
    .note{
      margin-top: 18px;
      font-size: 13px;
      color: #7a3d53;
      opacity: 0.9;
    }

    /* Confetti/hearts burst */
    .burst{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:visible;
      z-index:3;
    }

    /* Modal / success panel */
    .modal{
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 50;
      background: rgba(20,10,20,0.28);
      opacity: 0;
      transform: scale(.98);
      transition: opacity .18s ease, transform .2s cubic-bezier(.2,.9,.2,1);
      visibility: hidden;
    }
    .modal.show{ opacity:1; transform: none; visibility: visible; }
    .modal-card{
      background: linear-gradient(180deg,#fff,#fff7fb);
      border-radius: 16px;
      padding: 26px;
      width: min(92%, 560px);
      box-shadow: 0 20px 48px rgba(30,10,40,0.28);
      text-align:center;
    }
    .modal-card h2{
      margin: 0 0 8px 0; color: var(--accent-dark);
      font-family: 'Pacifico', cursive;
      font-size: 28px;
    }
    .modal-card p{ margin: 0 0 16px 0; color: #5b2a3e; }

    /* small friendly footer */
    .credit{
      margin-top:14px;
      font-size:12px;
      color:#8a435d;
      opacity:0.9;
    }

    /* Keep no-button jumps smooth */
    .btn--no.moving{
      transition: transform .28s cubic-bezier(.2,.9,.3,1), opacity .12s linear;
    }

    /* small responsive tweaks */
    @media (max-width:520px){
      .actions{ gap:12px; }
      .card{ padding: 20px; border-radius:16px; }
    }
  </style>
</head>
<body>

  <div class="bg-hearts" aria-hidden="true" id="hearts-container"></div>

  <main class="wrap">
    <section class="card" role="region" aria-labelledby="title">
      <h1 id="title">Will you be my Valentine?</h1>
      <p class="lead">Hey there is only one right answer, Also I love you lots Esposa</p>

      <div class="actions" id="actions">
        <button class="btn btn--yes" id="yesBtn" aria-label="Yes, I will be your valentine">Yes </button>
        <button class="btn btn--no" id="noBtn" aria-label="No, I won't" aria-hidden="false">No </button>
      </div>

      <p class="note"> Also the NO button is obviously the wrong answer so it runs away :) </p>

      <div class="credit">Made with love</div>

      <div class="burst" id="burst"></div>
    </section>
  </main>

  <!-- Modal shown after yes -->
  <div class="modal" id="modal" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-card" role="document">
      <h2>Yippie </h2>
      <p> I love you Alexa, I hope to see you soon</p>
      <button class="btn btn--yes" id="closeModal"> I love you more</button>
    </div>
  </div>

  <script>
    // ---------- Utilities ----------
    const rand = (min, max) => Math.random() * (max - min) + min;

    // ---------- Heart background setup ----------
    const heartsContainer = document.getElementById('hearts-container');
    // create many hearts with random timing
    for(let i=0;i<14;i++){
      const h = document.createElement('div');
      h.className = 'heart';
      const size = rand(18, 48);
      h.style.width = size + 'px';
      h.style.height = size + 'px';
      h.style.left = (rand(0, 100)) + 'vw';
      h.style.top = (rand(60, 120)) + 'vh';
      h.style.opacity = (rand(0.08, 0.28)).toFixed(2);
      h.style.transform = `scale(${(rand(0.75,1.05)).toFixed(2)})`;
      h.style.animationDuration = (rand(10, 28)).toFixed(1) + 's';
      h.style.animationDelay = (rand(-28, 0)).toFixed(1) + 's';
      heartsContainer.appendChild(h);
    }

    // ---------- Core interactive behavior ----------
    const yesBtn = document.getElementById('yesBtn');
    const noBtn = document.getElementById('noBtn');
    const actions = document.getElementById('actions');
    const modal = document.getElementById('modal');
    const closeModal = document.getElementById('closeModal');
    const burst = document.getElementById('burst');

    // keep track of container for bounding
    const card = document.querySelector('.card');

    // function to get bounding rect of card (viewport coords)
    function getCardRect(){
      return card.getBoundingClientRect();
    }

    // Return a random valid position for noBtn inside card
    function chooseNewNoPosition(){
      const cardRect = getCardRect();
      const actionsRect = actions.getBoundingClientRect();
      const yesRect = yesBtn.getBoundingClientRect();

      // Size of the "No" button (we will position via transform: translate)
      const noRect = noBtn.getBoundingClientRect();
      const btnW = noRect.width;
      const btnH = noRect.height;

      // Allowed area padding
      const padding = 12; // px inside the card
      const leftLimit = cardRect.left + padding;
      const rightLimit = cardRect.right - padding - btnW;
      const topLimit = cardRect.top + padding + 40;   // leave space for heading
      const bottomLimit = cardRect.bottom - padding - btnH - 10;

      // fallback if card is small:
      const minLeft = Math.min(leftLimit, rightLimit);
      const minTop = Math.min(topLimit, bottomLimit);

      let newLeft = rand(minLeft, Math.max(minLeft, rightLimit));
      let newTop  = rand(minTop, Math.max(minTop, bottomLimit));

      // ensure the no-button doesn't appear too close to the 'Yes' button
      const yesCenterX = yesRect.left + yesRect.width/2;
      const yesCenterY = yesRect.top + yesRect.height/2;

      // compute candidate center
      let tries = 0;
      while(tries < 14){
        const candCenterX = newLeft + btnW/2;
        const candCenterY = newTop + btnH/2;
        const dx = candCenterX - yesCenterX;
        const dy = candCenterY - yesCenterY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(dist > Math.max(120, Math.min(cardRect.width, cardRect.height)*0.25)){
          break;
        }
        // pick again
        newLeft = rand(minLeft, Math.max(minLeft, rightLimit));
        newTop  = rand(minTop, Math.max(minTop, bottomLimit));
        tries++;
      }

      // choose relative coordinates inside the actions parent (so transform can be applied)
      // We'll compute offsets relative to actions container (so that layout continues working)
      const actionsRect2 = actions.getBoundingClientRect();
      const offsetX = newLeft - actionsRect2.left;
      const offsetY = newTop - actionsRect2.top;

      return {x: offsetX, y: offsetY};
    }

    // Move the "No" button with a playful animation
    let moving = false;
    function moveNoButton(){
      if(moving) return; // throttle
      moving = true;
      noBtn.classList.add('moving');
      // temporarily disable pointer events while moving
      noBtn.setAttribute('aria-hidden', 'true');
      noBtn.style.pointerEvents = 'none';

      // small fade-out -> reposition -> fade-in
      noBtn.style.transition = 'opacity .12s linear, transform .28s cubic-bezier(.2,.9,.3,1)';
      noBtn.style.opacity = '0.08';

      // after fade-out, reposition
      setTimeout(()=>{
        const pos = chooseNewNoPosition();
        // apply transform in pixels: translate(x,y)
        noBtn.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
        // quick pop scale
        noBtn.style.opacity = '1';
      }, 140);

      // re-enable after animation
      setTimeout(()=>{
        noBtn.setAttribute('aria-hidden', 'false');
        noBtn.style.pointerEvents = '';
        noBtn.classList.remove('moving');
        moving = false;
      }, 520);
    }

    // Ensure initial layout places the noBtn at a pleasant starting spot (beside Yes)
    function placeNoAtStart(){
      // remove any transform first for a stable measure
      noBtn.style.transform = 'translate(0px, 0px)';
      // Compute a slightly offset position to the right of Yes if possible
      const actionsRect = actions.getBoundingClientRect();
      const yesRect = yesBtn.getBoundingClientRect();
      const noRect = noBtn.getBoundingClientRect();

      // default after Yes: 24px gap
      const desiredX = (yesRect.right - actionsRect.left) + 18;
      const desiredY = yesRect.top - actionsRect.top - (noRect.height - yesRect.height)/2;

      noBtn.style.transform = `translate(${Math.max(8, desiredX)}px, ${Math.max(-10, desiredY)}px)`;
    }

    // Attach hover and touch handlers
    // For desktop: mouseenter triggers move. For mobile: touchstart triggers move immediately.
    noBtn.addEventListener('mouseenter', (e)=>{
      moveNoButton();
    });
    noBtn.addEventListener('focus', (e)=>{
      // keyboard focus should also cause it to move away
      moveNoButton();
      yesBtn.focus(); // move focus back to yes to keep keyboard accessible
    });
    noBtn.addEventListener('touchstart', (e)=>{
      // on touch, stop default to avoid click; move and prevent tapping
      e.preventDefault();
      moveNoButton();
    }, {passive:false});

    // Extra trick: if the user tries to click, block it and move again
    noBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      moveNoButton();
    });

    // Rebalance positions in case of resize
    window.addEventListener('resize', () => {
      placeNoAtStart();
    });

    // If user moves mouse quickly to the No button (very determined), also nudge it on mousemove near it
    document.addEventListener('mousemove', (e)=>{
      const rect = noBtn.getBoundingClientRect();
      const mx = e.clientX;
      const my = e.clientY;

      // if mouse within 60px of center, move it
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const dx = mx - cx, dy = my - cy;
      const d = Math.sqrt(dx*dx + dy*dy);
      if(d < Math.max(60, rect.width)){
        moveNoButton();
      }
    });

    // ---------- Yes button behavior ----------
    yesBtn.addEventListener('click', async (e)=>{
      // small heart/confetti burst and show modal
      playBurst(e.clientX, e.clientY);
      showModal();
    });

    // create a burst of little hearts at a given point
    function playBurst(x = null, y = null){
      const rect = card.getBoundingClientRect();
      // if coordinates not provided, center on yes button
      if(!x || !y){
        const yesRect = yesBtn.getBoundingClientRect();
        x = yesRect.left + yesRect.width/2;
        y = yesRect.top + yesRect.height/2;
      }
      const localX = x - rect.left;
      const localY = y - rect.top;

      const count = 16;
      const particles = [];
      for(let i=0;i<count;i++){
        const p = document.createElement('div');
        p.className = 'heart';
        p.style.width = '14px';
        p.style.height = '14px';
        p.style.left = (localX + rand(-12, 12)) + 'px';
        p.style.top  = (localY + rand(-8, 8)) + 'px';
        p.style.opacity = 1;
        p.style.transform = `scale(${rand(.6,1.1)})`;
        p.style.transition = `transform ${rand(600,1200)}ms cubic-bezier(.2,.9,.2,1), opacity ${rand(600,1100)}ms linear`;
        burst.appendChild(p);
        particles.push(p);
      }
      // animate particles outward and fade
      setTimeout(()=>{
        particles.forEach((p, idx)=>{
          const angle = rand(0, Math.PI*2);
          const dist = rand(36, 140);
          const tx = Math.cos(angle) * dist;
          const ty = Math.sin(angle) * dist - rand(12, 48);
          p.style.transform = `translate(${tx}px, ${ty}px) scale(.6)`;
          p.style.opacity = 0;
        });
      }, 40);
      // remove after animation
      setTimeout(()=> particles.forEach(p => p.remove()), 1400);
    }

    // Show modal and confetti
    function showModal(){
      modal.classList.add('show');
      modal.setAttribute('aria-hidden', 'false');
      // quick hearts burst from yes button
      const yesRect = yesBtn.getBoundingClientRect();
      playBurst(yesRect.left + yesRect.width/2, yesRect.top + yesRect.height/2);

      // small continuous soft heart rain for extra bliss
      launchSoftHearts();
    }

    closeModal.addEventListener('click', ()=>{
      modal.classList.remove('show');
      modal.setAttribute('aria-hidden', 'true');
    });

    // Close modal when clicking outside modal-card
    modal.addEventListener('click', (ev)=>{
      if(ev.target === modal){
        modal.classList.remove('show');
        modal.setAttribute('aria-hidden', 'true');
      }
    });

    // Some soft heart particles for ambience when modal opens
    let softHeartsTimer = null;
    function launchSoftHearts(){
      clearInterval(softHeartsTimer);
      const container = burst;
      let launched = 0;
      softHeartsTimer = setInterval(()=>{
        if(launched > 18) { clearInterval(softHeartsTimer); return; }
        const p = document.createElement('div');
        p.className = 'heart';
        p.style.width = '18px';
        p.style.height = '18px';
        p.style.left = (rand(20, 80)) + '%';
        p.style.top  = (rand(60, 90)) + 'vh';
        p.style.opacity = 0.85;
        p.style.transform = `translateY(0) scale(${rand(.7,1.1)})`;
        p.style.transition = `transform ${rand(1400,2400)}ms cubic-bezier(.2,.9,.2,1), opacity ${rand(1400,2400)}ms linear`;
        container.appendChild(p);
        setTimeout(()=> {
          p.style.transform = `translateY(-140px) scale(.6)`;
          p.style.opacity = 0;
        }, 120);
        setTimeout(()=> p.remove(), 2600);
        launched++;
      }, 160);
    }

    // ---------- Accessibility helpers ----------
    // Keyboard support: pressing Enter or Space when Yes is focused triggers it.
    yesBtn.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        yesBtn.click();
      }
    });

    // Place No at start nicely once fonts and layout settle
    window.addEventListener('load', () => {
      // ensure initial subtle placement
      placeNoAtStart();

      // small playful move to show it's alive
      setTimeout(()=> moveNoButton(), 1100);
      setTimeout(()=> moveNoButton(), 2300);
    });

    // Ensure that if someone tries to cheat with keyboard navigation to No, the no button keeps moving away
    noBtn.addEventListener('keydown', (e)=>{
      if(['Enter',' '].includes(e.key)){
        e.preventDefault();
        moveNoButton();
      }
    });

    // Finally: keep No button unreachable if window is very small by making it a bit more shy
    const checkSmall = () => {
      if(window.innerWidth < 420){
        // on tiny screens make it move a little less violently but still dodge taps
        noBtn.addEventListener('touchstart', (e)=> {
          e.preventDefault();
          moveNoButton();
        }, {passive:false});
      }
    };
    checkSmall();
    window.addEventListener('resize', checkSmall);
  </script>
</body>
</html>
